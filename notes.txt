Notes:
1.
call stack { 
    Where all the Gec are kept
    [call stack(global execution context)] 
Gec - Global execution context will be known as ananymous
Componentes in GEC memory and code
Phases{
 p1 Memory creation phase occures befor executing single line
 p2 Code execution phase
}
brand new execution context after a function is invoked

2.
conole.log in gec
window and this {
    window- global object which is created along with the gec
    js code -> run -> global object -> gec -> along(this)
}    
this {
    object -> refers to object
    alone -> global object
    function -> global object
    event -> element that recvd the event
}
Global Space {
    Code in the js which is not inside the function
}

console.log(window.a = a = this.a)

3.
js- loosely typed language/ weakly typed language

4. Scope chain
Creted when gec -> ec is created
Lexical environment - local memory along with the lexical environment of its parent
Lexical- term in inhierarchy/ in sequence
c -> b -> a
The chain of lexical environment is known as scope chain, which lets to know that the variable is pesent or not

5. Let and Const
Let isnt hoisted like var
Let will not be stored at the global in the beginning like var did
temporal dead zone known as script
Temporal dead zone -> {
    Will create another context for variables which not yet assigned
    will ends if the variable got assigned to a value
    Accessing a undefined variable in the temporal dead zone will give:
        Uncaught Reference Error 
}
Let and Const will be present on a in separate storage
Doesnt lets to initialize value again if we did:
    Already initialized
Const -> Same rules like let but it is stricter
    const with no initialization:
        Missing Initizer in const declaration
Errors in variable {
Syntax error -> for const variable if its not assigned on the same line in the initialization
                         for let variable when we try to declare the same let variable again
Type error -> assigning the const variable again
Reference error -> when js finds hard to find reference for a variable before initialization
                              when the variable isnt defined       
}

Const -  Unchangable
let - temporal dead zone
var - in certain circunstances

add declarisation and initialization in the top area to get rid of errors occured by temporal dead zone


6. Block scope and shadowing in js
    Block - {Curly braces} Compound Statement -  Combine multiple js statements in one group
    Block Scope - What are the variables and functions we can access inside the block
    Shadoing - Same name variable outside the block (var a=10;)//{var a = 100 }
    let !-//> var but var -true//> let

7. Closure
    Closure is a function bind together with its lexical environment / bundled with its lexical environment or scope

Closures are created every time a function is created.
closure(lexical scope(function())) - 

Function along with its lexical scope forms a bundle known as closure

 return function y() { ...... }  = function y() { ..... } return y
[
function x() {
    var a = 7;
    function y() {
        console.log(a);
    }
    y();
}
x();
] - >{
    > closure (x)
        a: 7
}

uses of closure:
    module design pattern
    currying
    functions like once
    memoize
    maintaining state in async world
    set timeouts
    Iterators

8. Closure pt 2
    setTimeout :- It takes the callback function and attachches a timer of selected milliseconds and stores it somewhere

 9. First Class Functions   
    Function Statement & Function Declaration:-
        function a() {
            console.log("dinesh");
        }
       // Can be called before or after applying a function

    Function Expression:-
        var b = function () {
            console.log("dinesh");
        }
       // Because of hoisting b is said as to be a variable so that
           it can only called after the function expression has been set

    Anonymous Function:-
        function() {
           console.log("dinesh");
        }
        gives syntax error  ->  without defining into a variable

    Named Function Expression:-
        var b = function name() {
            console.log("dinesh");
        }
        gives uncaught ref: not defined error when we try to call the method initialized to the local variable

    Diff bwt Parameter & Arguments:-
                      parameters---> 
       function xyz(param1, param2) {}
            arguments--->
       xyz(1,3);

    First Class Functions:-
    The ability of functions to be used as values and can be passed as arguments to another function and returned from the functions is known as first class functions in js.

In short, ability to be used like values

    Arow Functions:-
    Es6 - ECMAScript 2015
    
11. Dom Selectors
DOM -> Document Object Model - tree structure representation created by the browser 
-> Each entry in the tree called a node
Programming Interface that allows us to create, change or remove elements from a awebsite document.
    -> getElementByTagName()
    -> getElementByClassName()
    -> getElementById()
    -> querySelector()
    -> querySelectorAll()

12. JS Datatypes
1. String 2.Number 3.Bigint 4.Boolean 5.Undefined 6.Null 7.Symbol 8. Object
1. Object 2. Array 3.Date

13. Callback Functions
    gives the power of asyncrounity
    asynchronous, non one by one
    adding a function inside a function parameter
 
    function x(y) {
    }
    x(function y() {
   
    });
Event listeners are heavy
good practice to remove event listeners
    
14. async js and event loop
call stack is a immediate, doesn't wait for no one, a call stack doesnt have a timer
call stack has access to various stuff ----!!Remarkable invention!!----
web api: contains global object "window"
Web api: not a part of js - superpowers
-> Set Timeout - 
-> Dom Api- "document."
-> fetch
-> localStorage
-> console
-> location
Event Loop:- 
-> Tho job of the EL Is to check the callback queue and puts the function in the callback queue inside the call stack
-> Continuously monitor the call stack as well as callback queue
---
[
console.log("Start");                   <--- logged first

setTimeout(function cb () {         <--- inside the callback queue
  console.log("CallBack");               <-- log inside the callback function (logged third)
} 5000);                                         <---timer of 5000 ms aka 5sec
 
console.log("End");                    <- logged second
]

console
[
Start
End
CallBack
]

callback queue [ (cb)        ]
---
fetch() :- 
-> Goes and requests a api call
-> fetch function returns a promise (.then)
-> we have to pass a callback function which will be executed once the promise is resolved ( When we get this data it will execute the function )
---
-> micro task queue and callback queue 
-> Promises and mutation observer goes inside the microtask queue
-> other callback function will goes inside call back queue
-> Task queue = callback Queue
-> callback functions in case of promises goes to the microtask queue
-> micro task queue has higher priority than callback queue
-> Even loop listens to the callback queue when all the microtasks in the microtask queue has completed until they are empty
---
Mutation Observer:-
keeps on checking if there is a mutation in the dom tree
if there is a mutation in dom tree then it executes the callback function
---
Starvation of the callback queue

15. Js Engine
JRE- Javascript Runtime Environment
JS Engine-
ECMAScript-
node.js 

steps in js engine
Code -> (ToKeNs) -> Parsing -> Compilation -> Execution
parsing stage:-
    syntax parser
    Ast - Abstract syntax tree
compilation stage:-
    JIT Compilation - Just in time compilation
    Usage of interpretter and compiler for the same code, while being fastly executed and being effiecint
    Interpretter:- Taskes the code and start executing one line by line. Fastly Executed
    Compiler:- Whole code compiled before executed and creates a optimized version of the code, Efficient
Js can behave like both interpretter and compiler
Browser cant wait for compile
Modren browser engine uses both interpretter and compiler
                --> 
compiler         interpretter
               <--
Aot- ahead of time compilation
Execution stage:-
interpretter converts the high level code to byte code and that code moves to execution steps
while using the optimization of code using compiler phase by phase
execution components: 
    -memory heap : space where all the memory is stored /where assigned
      garbage collector: mark and sweep algorithm
    -call stack : contains execution context and stuffs

Google v8 js engine:
Ingition- Intepreter
Turbofan- Compiler
Orinoco, Oil Pan- Garbage Colectors

Js Souce Code -> Parser -> Abstract Syntax Tree ----
                                                                                    |
compiler(Turbofan)      <----    Interpreter(ignition)<-
          |                                                |
Optimized machine      ---->        ByteCode
code

-mark & sweep
-Inlining 
-copy elision
- inline caching
-concurrency model

16. Higher order functions and functional programming
[].map(); -to map value one to one
[].filter(); - to filer elements in the array
[].reduce(); - iterates the function based upon the number of values in the array, accumulator and current value as parameter

DISCUSSION:
- Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.

Epic gist to refresh concepts:
Hoisting: 
Js hoisitng refers to the process whereby the interpreter appears to move the declaration of functions, variables or classes to the top of their scope, prior to execution of the code.

Async/ Await:
It simply allows us to write promises-based code as if it was synchronous and it checks that we are not breaking the execution thread. It makes sure that a promise is returned and if it is not returned then Js automatically wraps it in a promise which is resolved with its value. Await is used to wait for the promise. It could be used within the async block only. It makes the code wait until the promise returns a result. It only makes the async block wait.

Scope: 
Scope refers to the availability or accessibility of the variable and functions in our code. When you declare a variable outside any function or in the root script then that function or variable becomes global so you can access that from any part of your code but if you declare it inside a function or inside a block ({-block-}) then that variable can be accessed inside that function or that block only.

Callbacks:
Callbacksare nothing but the arguments of a function but instead of variable its a function. A callback function is simply a function passed into another function as an argument, which is then invoked inside the outer function.

Promises:
A promise is simply a placeholder for an asynchronous task which is yet to be completed. When you define a promise object in your script, instead of returning a value immediately, it returns a promise

------X--------
Asynchrony:
 Js engine doesn't run in isolation. It runs inside a hosting environment

17. Callback Pros and Cons:
 -> Using callback we can achieve asynchronous operations  in js, where we can execute a function in later point of time
 -> Callback hell- one callback inside another callback and goes on more unmaintainable (Pyramid of doom).
Inversion of control:-
   The problem in which the Developer will loose the control of their code while using callbacks

18. Promises:
Promise: Placeholder for a certain period of time until we receive a value for asynchrounous operation,
    -> A container for a future value
    ->MDN about Promise: Promise is an object representing the eventual completion or failure of an asynchrounous operation
-> Used to handle async operations in js
fetch() -  returns us a promise
-promise state -  what state the promise in
        Types of states in promise:
               -> Pending - initial state, not fullfilled nor rejected
               -> Fullfilled - Operation was completed successfully
               -> Rejected - The operation has failed
-promise result - will store the data the fetch method return
-promise objects are immutable
const promise = fetch(......some);

promise.then(...callbackfunction..)

callbackfunction() {
   ... lines of code....
}

Async and await:
Async amd await make promises easier to write

async makes a function return a promise
await makes a function wait for a promise


-30/1/2023-

Angular CLI- 
-> Command line interface tool that use to initialize, develop, scaffold, and maintain Angular applications directly from a command shell
-> Helps developers to create projects easily and quickly, 
-> Built on top of Node.js, installed from the NPM.

-31/1/2023

THIS OR That - (**Please ignore naming conventions) chapter 1 and 2
->If "this" really confuses like hell for you, it nothing but a object representing itself
-> This is actually a binding that is made when a function is invoked , and what it references is determined entirely by the call-site where the function is called
-> Function borrowing: we can borrow functions from other objects and use it with the data of some other objects
->Call: invokes the function and allows you to pass in arguments one by one.
            function.call(thisRepresentation, "Extra argument");
->Apply: invokes the function, allowing you to pass in areguments as an array.
               function.apply(thisRepresentation, ["Extra argument", "Extra 2" ]);
->Bind: returns a new function, allowing you to pass in a this array and any number of arguments
             let variableHoldsFunction = function.bind(thisRepresentation);
             variableHoldsFunction();
When to use:
Call and apply are interchangable
like normal args vs. array args
Call and apply will execute the current function immediately
which makes Bind unique
Bind reurns a new function, like we can really use if the function could return the desired value we can use the bind function to make a function to be holded to a variable, such that in execution the this/itself will executed will be runned later with the desired this/itself value.

The part where Mr.this will be a real pain:
Call site: 
The location where the function is called (not where its declared).
To find what mr.This will be refencing to will be determined by inspecting the call site.

The 4 Rules:
1. Called with new: Use the newly constructed object
2. Explicit: Called with call or apply or bind 
3. Implicit: Called with context object owning the call
4. Default: global object

Rule 1: Default binding:
standalone function invocation
default catch all rule wen none of the other rules apply
variables declared in global scope i.e associated with global object


funcation fun() {
    console.log(this.a);
}
var a = 2;
fun(); // output:2

Rule 2: Implicit Binding:
call site having a context object i.e referred to as an owning or containing object

function fun() {
    console.log(this.a);
}
var obj = {
    a:2,
    fun:fun
};
obj.foo();

Rule 3: Explicit Binding:
To force a function call to use a particular object for this binding, without putting a property function reference on the object
Utilities
call() and apply() //refer 30/1/2023
makes to force the this to be a object we wanted to apply
Hard bind:
Bind(): (Updated): Returns a new function that is hard-coded to call the original function whith "this" context set as you specified 

Rule 4: new Binding:
Final rule for this binding
Use the newly constructed object

ES6: 
Instead of the those four binding rules 
arrow functions use lexical scoping for 'this' binding
Syntactic replacement of self = this in pre-ES6 coding.
--

MVVM:
similar to a mvc pattern
but mvvm is for gui( Graphical user interface)
Defines 3 layers:
          send notification
            ----->                        data binding
model            View Model <----------------> view <----> User
            <-----
            changes state

Mvvm and mvc:
View model's responsibility is facilitating the transporatation of data between the view adn model
the view is a simple presentation of the data given by the ViewModel

Model: (just like mvc!!)
refers to a domain model
data access layer

View:
The view is a structure/appearance what a user sees on the screen

View model:
Unlike mvc, mvvm has binder which automates communication between the view and its bound properties in the view model

--
ng new <foldername>
?Angular routing Yes
?Stylesheet CSS


